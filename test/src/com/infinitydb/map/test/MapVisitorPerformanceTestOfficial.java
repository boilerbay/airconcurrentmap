// Copyright (C) 1997-2017 Roger L. Deran. All Rights Reserved.
//
// THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE SECRETS
// OF Roger L Deran.  USE, DISCLOSURE, OR REPRODUCTION IS PROHIBITED
// WITHOUT PRIOR EXPRESS WRITTEN PERMISSION.
//
// Patent Pending.
//
// Roger L Deran. MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT
// THE SUITABILITY OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR
// NON-INFRINGEMENT. Roger L Deran. SHALL NOT BE LIABLE FOR
// ANY DAMAGES SUFFERED BY USER AS A RESULT OF USING,
// MODIFYING OR DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

package com.infinitydb.map.test;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Random;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.function.Supplier;
import java.util.stream.Collector;

import com.infinitydb.map.air.AirConcurrentMap;
import com.infinitydb.map.util.SimpleSamplingMatrix;
//import com.infinitydb.map.nitro.NitroConcurrentMap;
import com.infinitydb.map.visitor.MapVisitor;
import com.infinitydb.map.visitor.ThreadedMapVisitor;
import com.infinitydb.map.visitor.VisitableMap;
import com.infinitydb.map.visitor.VisitableMapWrapper;

/**
 * AirConcurrentMap Map can do very fast callback iterations to scan a Map using
 * visitors that extend {@link MapVisitor}. These MapVisitor scans are much
 * faster than traditional Iterators by providing a single method invocation per
 * entry and for other reasons. The visit() method is atomic, while the two
 * Iteration methods - hasNext() and next() - may disagree if there is
 * concurrent modification, and can even cause sporadic NoSucElementExceptions.
 * 
 * For even more speed, AirConcurrentMap can use internal threads in order to
 * use multiple cores without significant client code. The client provides an
 * extension of {@link ThreadedMapVisitor}, which in turn extends MapVisitor.
 * The extension simply adds a split() method and a merge() method to allow the
 * threads to make temporary copies of the visitor object while the concurrent
 * visition is in progress.
 * 
 * There are more ConcurrentMaps in development that support the VisitableMap
 * interface, with and without threading. Any normal Map can also be wrapped
 * with {@link VisitableMapWrapper} to adapt it to the MapVisitor
 * interface.
 *
 * This test shows the performance of a variety of scanning techniques,
 * including the Java 8 streams, both serial and parallel.
 * 
 * Compile with Java 1.8 or later to get the streams functionality.
 * 
 * A result file can is printed to rwork/rOutput.Visitors.Logarithmic.txt or
 * rwork/rOutput.Visitors.Linear.txt depending on the IS_LOGARITHMIC boolean.
 * The file can be imported into and plotted in R with ggplot, and the results
 * are shown in documents delivered with along with this test.
 *
 * @author Roger
 **/
public class MapVisitorPerformanceTestOfficial {

    // where we stop in total Entry count.
    static final long MAX = 16 * 1024 * 1024L;
    // How many loops we do for the first test. Then
    // as we increase entries, we divide loops down by
    // the number of entries to keep the time constant.
    // Try to keep each iteration above about 1/2 second.
    static final long LOOPS = 1 * 1024 * 1024L;
    // Whether to increase by a fixed increment or a fixed multiple
    static final boolean IS_LOGARITHMIC = true;
    // Can be anything. Good are 2 or 10 for example.
    static final double LOG_BASE = 10;
    // 0.5 gives two steps per full step by the LOG_BASE, 0.25 gives four etc.
    static final double LOG_EXPONENT = 1.0 / 10;
    // if IS_LOGARITHMIC is false, here are the linear increments
    static final long LINEAR_STEP_SIZE = 100 * 1000;
    // static final long LINEAR_STEP_SIZE = 10 * 1000;
    // allow the initial very fast steps to be skipped to see the 'big data'
    // zone
    static final long LINEAR_FIRST_STEP = 10 * 1000;

    // static final long LINEAR_FIRST_STEP = 1000 * 1000;

    static final boolean PRINT_R_OUTPUT_FILE = false;

    /*
     * Each of these is a possible test, generating a single curve on the result
     * graph generated by the R script, and having a curve label corresponding
     * to the TestID. Each corresponds to a method like testAirKeys().
     * 
     * CSLM stands for java.util.concurrent.ConcurrentSkipListMap, and CHM is
     * ConcurrentHashMap, which are the standard Java library concurrent Maps.
     * AirConcurrentMap, NitroConcurrentMap, OxyConcurrentMap, and
     * ConcurrentSortedArrayForPatent are Boiler Bay proprietary. This test
     * setup is for showing why they perform better. Nitro and Oxy are in
     * development.
     */
    enum TestID {
        AIR_KEYS, AIR_ENTRIES, AIR_VALUES, AIR_VISIT, AIR_THD, AIR_STR, AIR_STR_PAR,
        NITRO_KEYS, NITRO_ENTRIES, NITRO_VALUES, NITRO_VIS, NITRO_THD,
        OXY_KEYS, OXY_ENTRIES, OXY_VALUES, OXY_VISIT,
        CSLM_KEYS, CSLM_ENTRIES, CSLM_VALUES, CSLM_STR, CSLM_STR_PAR,
        CHM_KEYS, CHM_ENTRIES, CHM_VALUES, CHM_STR, CHM_STR_PAR,
        HASH_KEYS, HASH_ENTRIES, HASH_VALUES, HASH_STR, HASH_STR_PAR,
        TREE_KEYS, TREE_ENTRIES, TREE_VALUES, TREE_STR, TREE_STR_PAR,
        CSAFP_KEYS
    }

    /*
     * The way a particular test is run. Each TestID has one setting for this.
     * This controls the logic inside testOne() independent of the Map
     * implementation. The Visit TestTypes are Boiler Bay proprietary: look at
     * VisitableMap, MapVisitor, and ThreadedMapVisitor. The stream ones come
     * from the Java 8 Streams feature.
     */
    enum TestType {
        ITERATE_KEYS, ITERATE_ENTRIES, ITERATE_VALUES,
        VISIT, VISIT_THREADED,
        STREAM, PARALLEL_STREAM
    }

    /*
     * The algorithm executed for each Iteration, Visitor visit invocation, or
     * Stream reduce step. The COUNT is very fast, and shows the outer limits of
     * speed. SUM is slower, but the conditional ones COUNT_POSITIVE and MAX are
     * much slower than that. The Collection algorithms are very slow because
     * they put entries into destination collections, CSLM or Air.
     */
    enum TestAlgorithm {
        COUNT, SUM, COUNT_POSITIVE, MAX, COLLECT, COLLECT_INVERTED, BIG_OPERATION
    }

    /*
     * Set this to configure a test run.
     */
    static final TestAlgorithm TEST_ALGORITHM = TestAlgorithm.SUM;

    // For TestAlgorithm.COLLECT and COLLECT_INVERTED
    enum CollectionDestination {
        NONE, AIR, CSLM
    }

    /*
     * Set this to configure a test run.
     * 
     * Only relevant when TEST_ALGORITHM == TestAlgorithm.COLLECT or
     * COLLECT_INVERTED.
     */
    static final CollectionDestination COLLECTION_DESTINATION =
            CollectionDestination.CSLM;

    Random random = new Random(0);
    /*
     * FastRandom is a Mersenne twister, and is fast but weak, with less than
     * 2^64 states - approximately 2^32 states, hence will produce collisions.
     * That is not particularly important in this test.
     */
    // FastRandom fastRandom = new FastRandom(0, 100);

    /*
     * For collecting results as a matrix with columns that are TestIDs and rows
     * that are for tested Map sizes and cells that are performance results. The
     * Map sizes can be linear or logarithmic. This is printed to stdout on
     * completion, not the R file.
     */
    static SimpleSamplingMatrix<Long, TestID, Double> results =
            new SimpleSamplingMatrix<Long, TestID, Double>(
                    " count  ", TestID.class, "%9s ", "%8d ", "%8.3f ");

    public MapVisitorPerformanceTestOfficial() {
        Runtime.getRuntime().gc();
    }

    /*
     * The output to a file for collecting data for R to graph. The TestID is a
     * column so the file is one relation of space- separated columns of real
     * numbers at the left followed by one column of TestID.
     */
    static PrintStream rStream;

    public static void beforeClass() {
        printParameters();
        if (PRINT_R_OUTPUT_FILE) {
            try {
                System.out.println("cwd=" + System.getProperty("user.dir"));
                rStream = new PrintStream(new FileOutputStream(
                        "rwork/rOutput.Visitors." + (IS_LOGARITHMIC ? "Logarithmic" : "Linear") + ".txt"));
                rStream.printf("%8s %8s %9s %8s %15s\n", "i", "time", "speed", "check", "test");
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
        }
    }

    public static void afterClass() {
        printParameters();
        results.print();
        if (PRINT_R_OUTPUT_FILE)
            rStream.close();
    }

    static void rPrintf(String format, Object... o) {
        if (PRINT_R_OUTPUT_FILE)
            rStream.printf(format, o);
    }

    static void sPrintf(String format, Object... o) {
        System.out.printf(format, o);
    }

    static void rPrintln(Object... o) {
        if (PRINT_R_OUTPUT_FILE)
            rStream.println(o);
        System.out.println(o);
    }

    // AIR

    public void testAirIterateKeys() {
        testOne(TestID.AIR_KEYS, new AirConcurrentMap<Object, Object>(), TestType.ITERATE_KEYS);
    }

    public void testAirIterateEntries() {
        testOne(TestID.AIR_ENTRIES, new AirConcurrentMap<Object, Object>(), TestType.ITERATE_ENTRIES);
    }

    public void testAirIterateValues() {
        testOne(TestID.AIR_VALUES, new AirConcurrentMap<Object, Object>(), TestType.ITERATE_VALUES);
    }

    public void testAirVisit() {
        testOne(TestID.AIR_VISIT, new AirConcurrentMap<Object, Object>(), TestType.VISIT);
    }

    public void testAirVisitThreaded() {
        testOne(TestID.AIR_THD, new AirConcurrentMap<Object, Object>(), TestType.VISIT_THREADED);
    }

    public void testAirStream() {
        testOne(TestID.AIR_STR, new AirConcurrentMap<Object, Object>(), TestType.STREAM);
    }

    public void testAirParallelStream() {
        testOne(TestID.AIR_STR_PAR, new AirConcurrentMap<Object, Object>(), TestType.PARALLEL_STREAM);
    }

    // NITRO

    // public void testNitroMapIterateKeys() {
    // testOne(TestID.NITRO_KEYS, new NitroConcurrentMap<Object, Object>(),
    // TestType.ITERATE_KEYS);
    // }
    //
    // public void testNitroMapIterateEntries() {
    // testOne(TestID.NITRO_ENTRIES, new NitroConcurrentMap<Object, Object>(),
    // TestType.ITERATE_ENTRIES);
    // }
    //
    // public void testNitroMapIterateValues() {
    // testOne(TestID.NITRO_VALUES, new NitroConcurrentMap<Object, Object>(),
    // TestType.ITERATE_VALUES);
    // }
    //
    // public void testNitroMapVisit() {
    // testOne(TestID.NITRO_VIS, new NitroConcurrentMap<Object, Object>(),
    // TestType.VISIT);
    // }
    //
    // public void testNitroMapVisitThreaded() {
    // testOne(TestID.NITRO_THD, new NitroConcurrentMap<Object, Object>(),
    // TestType.VISIT_THREADED);
    // }

    // OXY

    //
    //
    // public void testOxyIterateKeys() {
    // testOne(TestID.OXY_KEYS, new OxyConcurrentMap<Object, Object>(),
    // TestType.ITERATE_KEYS);
    // }
    //
    //
    //
    // public void testOxyIterateEntries() {
    // testOne(TestID.OXY_ENTRIES, new OxyConcurrentMap<Object, Object>(),
    // TestType.ITERATE_ENTRIES);
    // }
    //
    //
    //
    // public void testOxyIterateValues() {
    // testOne(TestID.OXY_VALUES, new OxyConcurrentMap<Object, Object>(),
    // TestType.ITERATE_VALUES);
    // }
    //
    //
    //
    // public void testOxyVisit() {
    // testOne(TestID.OXY_VISIT, new OxyConcurrentMap<Object, Object>(),
    // TestType.VISIT);
    // }

    // CLSM

    public void testCSLMIterateKeys() {
        testOne(TestID.CSLM_KEYS, new ConcurrentSkipListMap<Object, Object>(), TestType.ITERATE_KEYS);
    }

    public void testCSLMIterateEntries() {
        testOne(TestID.CSLM_ENTRIES, new ConcurrentSkipListMap<Object, Object>(), TestType.ITERATE_ENTRIES);
    }

    public void testCSLMIterateValues() {
        testOne(TestID.CSLM_VALUES, new ConcurrentSkipListMap<Object, Object>(), TestType.ITERATE_VALUES);
    }

    public void testCSLMStream() {
        testOne(TestID.CSLM_STR, new ConcurrentSkipListMap<Object, Object>(), TestType.STREAM);
    }

    public void testCSLMParallelStream() {
        testOne(TestID.CSLM_STR_PAR,
                new ConcurrentSkipListMap<Object, Object>(),
                TestType.PARALLEL_STREAM);
    }

    // CHM

    public void testCHMIterateKeys() {
        testOne(TestID.CHM_KEYS, new ConcurrentHashMap<Object, Object>(), TestType.ITERATE_KEYS);
    }

    public void testCHMIterateEntries() {
        testOne(TestID.CHM_ENTRIES, new ConcurrentHashMap<Object, Object>(), TestType.ITERATE_ENTRIES);
    }

    public void testCHMIterateValues() {
        testOne(TestID.CHM_VALUES, new ConcurrentHashMap<Object, Object>(), TestType.ITERATE_VALUES);
    }

    public void testCHMStream() {
        testOne(TestID.CHM_STR, new ConcurrentHashMap<Object, Object>(), TestType.STREAM);
    }

    public void testCHMParallelStream() {
        testOne(TestID.CHM_STR_PAR,
                new ConcurrentHashMap<Object, Object>(),
                TestType.PARALLEL_STREAM);
    }

    // TREEMAP

    public void testTreeMapIterateKeys() {
        testOne(TestID.TREE_KEYS, new TreeMap<Object, Object>(), TestType.ITERATE_KEYS);
    }

    public void testTreeMapIterateEntries() {
        testOne(TestID.TREE_ENTRIES, new TreeMap<Object, Object>(), TestType.ITERATE_ENTRIES);
    }

    public void testTreeMapIterateValues() {
        testOne(TestID.TREE_VALUES, new TreeMap<Object, Object>(), TestType.ITERATE_VALUES);
    }

    public void testTreeStream() {
        testOne(TestID.TREE_STR, new TreeMap<Object, Object>(), TestType.STREAM);
    }

    public void testTreeParallelStream() {
        testOne(TestID.TREE_STR_PAR, new TreeMap<Object, Object>(), TestType.PARALLEL_STREAM);
    }

    // HASHMAP

    public void testHashMapIterateKeys() {
        testOne(TestID.HASH_KEYS, new HashMap<Object, Object>(), TestType.ITERATE_KEYS);
    }

    public void testHashMapIterateEntries() {
        testOne(TestID.HASH_ENTRIES, new HashMap<Object, Object>(), TestType.ITERATE_ENTRIES);
    }

    public void testHashMapIterateValues() {
        testOne(TestID.HASH_VALUES, new HashMap<Object, Object>(), TestType.ITERATE_VALUES);
    }

    // Hash Streaming is even slower than ConcurrentHashStreaming.
    public void testHashStream() {
        testOne(TestID.HASH_STR, new HashMap<Object, Object>(), TestType.STREAM);
    }

    public void testHashParallelStream() {
        testOne(TestID.HASH_STR_PAR, new HashMap<Object, Object>(), TestType.PARALLEL_STREAM);
    }

    // We increment this and print it just so the compiler cannot
    // possibly remove any code.
    long check;

    static class CountingVisitor extends MapVisitor<Object, Object> {
        private long count;

        long getCount(VisitableMap<Object, Object> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public void visit(Object k, Object v) {
            count++;
        }

        long getCount() {
            return count;
        }
    }

    static class ThreadedCountingVisitor<K, V>
            extends ThreadedMapVisitor<K, V> {
        private long count;

        @Override
        public void visit(Object k, Object v) {
            count++;
        }

        long getCount(VisitableMap<K, V> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public ThreadedMapVisitor<K, V> split() {
            return new ThreadedCountingVisitor<K, V>();
        }

        @Override
        public void merge(ThreadedMapVisitor<K, V> visitor) {
            count += ((ThreadedCountingVisitor<K, V>)visitor).count;
        }
    }

    static class SummingVisitor<K> extends MapVisitor<K, Long> {
        private long sum;

        long getSum(VisitableMap<K, Long> map) {
            sum = 0;
            map.getVisitable().visit(this);
            return sum;
        }

        @Override
        public void visit(Object k, Long v) {
            sum += ((Long)v).longValue();
        }

        long getSum() {
            return sum;
        }
    }

    static class ThreadedSummingVisitor<K> extends ThreadedMapVisitor<K, Long> {
        private long sum;

        long getSum(VisitableMap<K, Long> map) {
            sum = 0;
            map.getVisitable().visit(this);
            return sum;
        }

        @Override
        public void visit(Object k, Long v) {
            // TODO REMOVE
            // sum += ((Long)(new SimpleImmutableEntry<Object, Long>(k,
            // v).getValue())).longValue();
            sum += ((Long)v).longValue();
        }

        @Override
        public ThreadedMapVisitor<K, Long> split() {
            return new ThreadedSummingVisitor<K>();
        }

        @Override
        public void merge(ThreadedMapVisitor<K, Long> visitor) {
            sum += ((ThreadedSummingVisitor<K>)visitor).sum;
        }
    }

    static class MaxVisitor<K> extends MapVisitor<K, Long> {
        long max;

        long getMax(VisitableMap<K, Long> map) {
            max = 0;
            map.getVisitable().visit(this);
            return max;
        }

        @Override
        public void visit(Object k, Long v) {
            max = max > v.longValue() ? max : v.longValue();
        }
    }

    static class ThreadedMaxVisitor<K> extends ThreadedMapVisitor<K, Long> {
        long max;

        long getMax(VisitableMap<K, Long> map) {
            max = 0;
            map.getVisitable().visit(this);
            return max;
        }

        @Override
        public void visit(Object k, Long v) {
            max = max > v.longValue() ? max : v.longValue();
        }

        @Override
        public ThreadedMapVisitor<K, Long> split() {
            return new ThreadedMaxVisitor<K>();
        }

        @Override
        public void merge(ThreadedMapVisitor<K, Long> visitor) {
            max = max > ((ThreadedMaxVisitor<K>)visitor).max ?
                    max : ((ThreadedMaxVisitor<K>)visitor).max;
        }
    }

    static class CountingPositiveVisitor<K> extends MapVisitor<K, Long> {
        private long count;

        long getCount(VisitableMap<K, Long> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public void visit(Object k, Long v) {
            if (((Long)v).longValue() > 0)
                count++;
        }
    }

    static class ThreadedCountingPositiveVisitor<K>
            extends ThreadedMapVisitor<K, Long> {
        private long count;

        long getCount(VisitableMap<K, Long> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public void visit(Object k, Long v) {
            if (v.longValue() > 0)
                count++;
        }

        @Override
        public ThreadedMapVisitor<K, Long> split() {
            return new ThreadedCountingPositiveVisitor<K>();
        }

        @Override
        public void merge(ThreadedMapVisitor<K, Long> visitor) {
            count += ((ThreadedCountingPositiveVisitor<K>)visitor).count;
        }
    }

    /**
     * Put all the Entries in a given VisitableMap into another Map. This is
     * just a copy operation but can be faster especially when threaded.
     * 
     * There is also a 'clone()' that takes no collectingMap parameter but
     * quickly returns the clone from a clone() method.
     * 
     * @author Roger
     *
     * @param <K>
     * @param <V>
     */
    static class CollectingVisitor<K, V> extends MapVisitor<K, V> {
        protected Map<K, V> collectingMap;

        Map<K, V> collect(VisitableMap<K, V> map, Map<K, V> collectingMap) {
            this.collectingMap = collectingMap;
            // We could use a visit(this, false) if faster.
            map.getVisitable().visit(this);
            return collectingMap;
        }

        Map<K, V> clone(VisitableMap<K, V> map) {
            collectingMap = COLLECTION_DESTINATION == CollectionDestination.AIR ?
                    new AirConcurrentMap<K, V>() : new ConcurrentSkipListMap<K, V>();
            // We could use a visit(this, false) if faster.
            map.getVisitable().visit(this);
            return collectingMap;
        }

        @Override
        public void visit(K k, V v) {
            collectingMap.put(k, v);
        }
    }

    /**
     * Here we make the choice to share one collectingMap between the split-off
     * visitors used by different threads. We could have had each split-off
     * visitor use its own, and then combine them in merge(). This flexibility
     * provides many optimization opportunities.
     */
    static class ThreadedCollectingVisitor<K, V> extends ThreadedMapVisitor<K, V> {
        private Map<K, V> collectingMap;

        Map<K, V> collect(VisitableMap<K, V> map, Map<K, V> collectingMap) {
            // We could use a visitUnordered() if faster, though non-parallel.
            this.collectingMap = collectingMap;
            map.getVisitable().visit(this);
            return collectingMap;
        }

        Map<K, V> clone(VisitableMap<K, V> map) {
            collectingMap = makeCollectionDestinationMap();
            // We could use a visitUnordered() if faster, though non-parallel.
            // Note don't accidentally use a non-parallel visit!
            map.getVisitable().visit(this);
            return collectingMap;
        }

        @Override
        public void visit(K k, V v) {
            collectingMap.put(k, v);
        }

        @Override
        public ThreadedMapVisitor<K, V> split() {
            ThreadedCollectingVisitor v = new ThreadedCollectingVisitor();
            v.collectingMap = this.collectingMap;
            return v;
        }

        @Override
        public void merge(ThreadedMapVisitor<K, V> visitor) {
        }
    }

    static class InvertedCollectingVisitor<K, V> extends MapVisitor<K, V> {
        protected Map<V, K> collectingMap;

        Map<V, K> collect(VisitableMap<K, V> map, Map<V, K> collectingMap) {
            this.collectingMap = collectingMap;
            // We could use a visitUnordered() if faster.
            map.getVisitable().visit(this);
            return collectingMap;
        }

        @Override
        public void visit(K k, V v) {
            collectingMap.put(v, k);
        }
    }

    static class ThreadedInvertedCollectingVisitor<K, V> extends ThreadedMapVisitor<K, V> {
        private Map<V, K> collectingMap;

        Map<V, K> collect(VisitableMap<K, V> map, Map<V, K> collectingMap) {
            // We could use a visitUnordered() if faster.
            this.collectingMap = collectingMap;
            map.getVisitable().visit(this);
            return collectingMap;
        }

        @Override
        public void visit(K k, V v) {
            collectingMap.put(v, k);
        }

        @Override
        public ThreadedMapVisitor<K, V> split() {
            ThreadedInvertedCollectingVisitor v = new ThreadedInvertedCollectingVisitor();
            v.collectingMap = this.collectingMap;
            return v;
        }

        @Override
        public void merge(ThreadedMapVisitor<K, V> visitor) {
        }
    }

    // Do nothing particularly useful.
    // A long-running iterator and visitor operation per thread
    // Do not make this volatile or the threading won't be fast.
    // Note there will be lost increments in parallel mode.
    static long bigOperationCount;

    static long bigOperation(Object k, Object v) {
        bigOperationCount = 1;
        for (int i = 0; i < 10; i++) {
            bigOperationCount += ((Long)v).longValue();
        }
        for (int i = 0; i < 10; i++) {
            bigOperationCount -= ((Long)v).longValue();
        }
        return bigOperationCount;
    }

    static class BigOperationVisitor<K, V> extends MapVisitor<K, V> {
        long count;

        long getCount(VisitableMap<K, V> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public void visit(K k, V v) {
            count += bigOperation(k, v);
        }
    }

    // Do nothing particularly useful very fast.
    static class ThreadedBigOperationVisitor<K, V> extends ThreadedMapVisitor<K, V> {
        long count;

        long getCount(VisitableMap<K, V> map) {
            count = 0;
            map.getVisitable().visit(this);
            return count;
        }

        @Override
        public void visit(K k, V v) {
            count += bigOperation(k, v);
        }

        @Override
        public ThreadedMapVisitor<K, V> split() {
            return new ThreadedBigOperationVisitor<K, V>();
        }

        @Override
        public void merge(ThreadedMapVisitor<K, V> visitor) {
            count += ((ThreadedBigOperationVisitor<K, V>)visitor).count;
        }
    }

    void testOne(TestID testId, Map<Object, Object> map, TestType testType) {
        System.out.println();
        System.out.println("map = " + map.getClass() + " visiting=" + testType);
        System.out.printf("%8s %8s %9s %16s %9s %9s %9s %15s\n",
                "i", "time", "speed", "check", "totalMB", "freeMB", "usedMB", "testID");
        Runtime.getRuntime().gc();
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
        }

        long lastI = 0;

        for (double x = IS_LOGARITHMIC ? 1 : LINEAR_FIRST_STEP; x <= MAX; x = iIncremented(x)) {
            Runtime.getRuntime().gc();
            long i = (long)x;
            check = 0;
            for (long j = lastI; j < i; j++) {
                Object key = random.nextLong();
                // Object key = fastRandom.nextLong();
                map.put(key, key);
            }
            lastI = i;
            long t0 = System.nanoTime();
            long loops = LOOPS / i;
            if (loops == 0)
                loops = 1;
            switch (testType) {
            case ITERATE_KEYS :
                for (long j = 0; j < loops; j++) {
                    long count = 0;
                    Map<Object, Object> collectionMap = makeCollectionDestinationMap();
                    for (Object k : map.keySet()) {
                        // cannot use switch here, as JIT does not optimize it
                        // away!
                        if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                            collectionMap.put(k, k);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                            collectionMap.put(k, k);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                            count = ((Long)k).longValue() > 0 ? count + 1 : count;
                        } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                            count = count > ((Long)k).longValue() ? count : ((Long)k).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                            count += ((Long)k).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                            count++;
                        } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                            count += bigOperation(k, k);
                        }
                    }
                    check += count;
                }
                break;
            case ITERATE_ENTRIES :
                for (long j = 0; j < loops; j++) {
                    long count = 0;
                    Map<Object, Object> collectionMap = makeCollectionDestinationMap();
                    for (Object o : map.entrySet()) {
                        Entry<Long, Long> e = (Entry<Long, Long>)o;
                        Long k = e.getKey();
                        Long v = e.getValue();
                        // cannot use switch here, as JIT does not optimize it
                        // away!
                        if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                            collectionMap.put(k, v);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                            collectionMap.put(v, k);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                            count = ((Long)v).longValue() > 0 ? count + 1 : count;
                        } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                            count = count > ((Long)v).longValue() ? count : ((Long)v).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                            count += ((Long)v).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                            count++;
                        } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                            count += bigOperation(k, v);
                        }
                    }
                    check += count;
                }
                break;
            case ITERATE_VALUES :
                for (long j = 0; j < loops; j++) {
                    long count = 0;
                    Map<Object, Object> collectionMap = makeCollectionDestinationMap();
                    for (Object v : map.values()) {
                        // cannot use switch here, as JIT does not optimize it
                        // away!
                        if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                            collectionMap.put(v, v);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                            collectionMap.put(v, v);
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                            count = ((Long)v).longValue() > 0 ? count + 1 : count;
                        } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                            count = count > ((Long)v).longValue() ? count : ((Long)v).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                            count += ((Long)v).longValue();
                        } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                            count++;
                        } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                            count += bigOperation(v, v);
                        }
                    }
                    check += count;
                }
                break;
            case VISIT :
                for (long j = 0; j < loops; j++) {
                    if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                        check += new CountingPositiveVisitor().getCount((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                        check += new CountingVisitor().getCount((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                        check += new SummingVisitor().getSum((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                        check += new MaxVisitor().getMax((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                        Map rslt = new CollectingVisitor().collect((VisitableMap)map, makeCollectionDestinationMap());
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                        Map rslt = new InvertedCollectingVisitor().collect((VisitableMap)map, makeCollectionDestinationMap());
                    } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                        check += new BigOperationVisitor().getCount((VisitableMap)map);
                    }
                }
                break;
            case VISIT_THREADED :
                for (long j = 0; j < loops; j++) {
                    if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                        check += new ThreadedCountingPositiveVisitor().getCount((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                        check += new ThreadedCountingVisitor().getCount((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                        // TODO UNDO
                        check += new ThreadedSummingVisitor().getSum((VisitableMap)map);
                        // check += new
                        // ThreadedConstructingVisitor().getSum((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                        check += new ThreadedMaxVisitor().getMax((VisitableMap)map);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                        Map rslt = new ThreadedCollectingVisitor().collect((VisitableMap)map, makeCollectionDestinationMap());
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                        Map rslt = new ThreadedInvertedCollectingVisitor().collect((VisitableMap)map, makeCollectionDestinationMap());
                    } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                        check += new ThreadedBigOperationVisitor().getCount((VisitableMap)map);
                    }
                }
                break;
            case STREAM :
                long result = 0;
                for (long j = 0; j < loops; j++) {
                    if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                        result = map.values()
                                .stream()
                                .mapToLong(v -> ((Long)v).longValue())
                                .sum();

                        // result = (Long)((ConcurrentSkipListMap<Object,
                        // Object>)map).values()
                        // .stream()
                        // .reduce(0L, (v, p) -> v + ((Long)p).longValue(),
                        // (sum1, sum2) -> sum1 + sum2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                        result = map.values()
                                .stream()
                                .count();
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                        // result = map.entrySet()
                        // .stream()
                        // .reduce(0L, (count, v) ->
                        // ((Long)v.getValue()).longValue() >= 0 ?
                        // ((Long)count).longValue() + 1 :
                        // ((Long)count).longValue(),
                        // (count1, count2) -> count1 + count2);
                        result = map.values()
                                .stream()
                                .reduce(0L, (count, v) -> ((Long)v).longValue() >= 0 ?
                                        ((Long)count).longValue() + 1 :
                                        ((Long)count).longValue(),
                                        (count1, count2) -> count1 + count2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                        result = map.values()
                                .stream()
                                .reduce(0L, (max, v) -> ((Long)v).longValue() >= max ?
                                        ((Long)v).longValue() :
                                        ((Long)max).longValue(),
                                        (sum1, sum2) -> sum1 > sum2 ? sum1 : sum2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                        map.entrySet()
                                .stream()
                                .collect(makeCollector());
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                        map.entrySet()
                                .stream()
                                .collect(makeCollector());
                    } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                        result = map.values()
                                .stream()
                                .reduce(0L, (count, v) -> count + bigOperation(v, v),
                                        (sum1, sum2) -> sum1 + sum2);
                    }
                    check += result;
                }
                break;
            case PARALLEL_STREAM :
                result = 0;
                for (long j = 0; j < loops; j++) {
                    if (TEST_ALGORITHM == TestAlgorithm.SUM) {
                        result = map.values()
                                .stream()
                                .parallel()
                                .mapToLong(v -> ((Long)v).longValue())
                                .sum();
                        // result = map.values()
                        // .stream()
                        // .parallel()
                        // .reduce(0L, (v, p) -> v + ((Long)p).longValue(),
                        // (sum1, sum2) -> sum1 + sum2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT) {
                        result = map.values()
                                .stream()
                                .parallel()
                                .count();
                    } else if (TEST_ALGORITHM == TestAlgorithm.COUNT_POSITIVE) {
                        result = map.values()
                                .stream()
                                .parallel()
                                .reduce(0L, (count, v) -> ((Long)v).longValue() >= 0 ?
                                        ((Long)count).longValue() + 1 :
                                        ((Long)count).longValue(),
                                        (count1, count2) -> count1 + count2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.MAX) {
                        result = map.values()
                                .stream()
                                .parallel()
                                .reduce(0L, (max, v) -> ((Long)v).longValue() >= max ?
                                        ((Long)v).longValue() :
                                        ((Long)max).longValue(),
                                        (sum1, sum2) -> sum1 > sum2 ? sum1 : sum2);
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
                        map.entrySet()
                                .stream()
                                .parallel()
                                .collect(makeCollector());
                    } else if (TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED) {
                        map.entrySet()
                                .stream()
                                .parallel()
                                .collect(makeCollector());
                    } else if (TEST_ALGORITHM == TestAlgorithm.BIG_OPERATION) {
                        result = map.values()
                                .stream()
                                .parallel()
                                .reduce(0L, (count, v) -> count + bigOperation(v, v),
                                        (sum1, sum2) -> sum1 + sum2);
                    } else {
                        System.out.println("not impl");
                    }
                    check += result;
                }
            }
            long t1 = System.nanoTime();
            double duration = (t1 - t0) / 1e9;
            double speed = i * loops / duration / 1e6;
            double totalMemory = Runtime.getRuntime().totalMemory() / 1e6;
            double freeMemory = Runtime.getRuntime().freeMemory() / 1e6;
            double usedMemory = totalMemory - freeMemory;
            // System.out.println("size=" + map.size());
            rPrintf("%8.3f %8.3f %9.3f %016x %15s\n",
                    i / 1000.0, duration, speed, check,
                    testId.name());
            sPrintf("%8.3f %8.3f %9.3f %016x %9.3f %9.3f %9.3f %15s\n",
                    i / 1000.0, duration, speed, check,
                    totalMemory, freeMemory, usedMemory,
                    testId.name());
            results.put(new Long(i), testId, speed);
        }
    }

    // For AirConcurrentMap and newer Map's MapVisitor
    static Map makeCollectionDestinationMap() {
        return COLLECTION_DESTINATION == CollectionDestination.AIR ?
                new AirConcurrentMap()
                : COLLECTION_DESTINATION == CollectionDestination.CSLM ?
                        new ConcurrentSkipListMap()
                        : null;
    }

    // For Java 8 stream
    static Collector<Entry<Object, Object>, ? , Map<Object, Object>> makeCollector() {

        Supplier<Map<Object, Object>> supplier =
                COLLECTION_DESTINATION == CollectionDestination.AIR ?
                        AirConcurrentMap<Object, Object>::new :
                        ConcurrentSkipListMap<Object, Object>::new;
        // BiConsumer<Map<Object, Object>, Entry<Object, Object>> accum =
        // TEST_ALGORITHM == TestAlgorithm.COLLECT ?
        // (m, e) -> m.put(e.getKey(), e.getValue()) :
        // (m, e) -> m.put(e.getValue(), e.getKey());
        if (TEST_ALGORITHM == TestAlgorithm.COLLECT) {
            return Collector.of(supplier, (m, e) -> m.put(e.getKey(), e.getValue()),
                    (m1, m2) -> {
                        m1.putAll(m2);
                        return m1;
                    });
        } else {
            return Collector.of(supplier, (m, e) -> m.put(e.getValue(), e.getKey()),
                    (m1, m2) -> {
                        m1.putAll(m2);
                        return m1;
                    });
        }
    }

    double iIncremented(double i) {
        return IS_LOGARITHMIC ?
                (i == 0 ? 1 : (double)i * Math.pow(LOG_BASE, LOG_EXPONENT)) + Double.MIN_VALUE :
                (i / LINEAR_STEP_SIZE * LINEAR_STEP_SIZE) + LINEAR_STEP_SIZE;
    }

    static void printParameters() {
        System.out.print("VisitAlgorithm=" + TEST_ALGORITHM);
        if (TEST_ALGORITHM == TestAlgorithm.COLLECT ||
                TEST_ALGORITHM == TestAlgorithm.COLLECT_INVERTED)
            System.out.println("  CollectionDestination=" + COLLECTION_DESTINATION);
        System.out.println();
        printProperty("java.version");
        printProperty("os.arch");
        long maxMem = Runtime.getRuntime().maxMemory() / 1000 / 1000;
        System.out.println("maxMemory=" + maxMem + "M");
    }

    static void printProperty(String name) {
        System.out.println(name + "=" + System.getProperties().getProperty(name));
    }

    public static void main(String... args) {
        try {
            beforeClass();
            if (true) {
                new MapVisitorPerformanceTestOfficial().testAirIterateKeys();
                new MapVisitorPerformanceTestOfficial().testCSLMIterateKeys();
                new MapVisitorPerformanceTestOfficial().testCHMIterateKeys();
                new MapVisitorPerformanceTestOfficial().testTreeMapIterateKeys();
                new MapVisitorPerformanceTestOfficial().testHashMapIterateKeys();
                // Future Maps
                // new
                // MapVisitorPerformanceTestOfficial().testNitroMapIterateKeys();
                // new MapVisitorPerformanceTestOfficial().testOxyIterateKeys();
            }
            if (false) {
                new MapVisitorPerformanceTestOfficial().testAirIterateEntries();
                // new
                // MapVisitorPerformanceTestOfficial().testNitroMapIterateEntries();
                // new
                // MapVisitorPerformanceTestOfficial().testOxyIterateEntries();
                new MapVisitorPerformanceTestOfficial().testCSLMIterateEntries();
                new MapVisitorPerformanceTestOfficial().testCHMIterateEntries();
                new MapVisitorPerformanceTestOfficial().testTreeMapIterateEntries();
                new MapVisitorPerformanceTestOfficial().testHashMapIterateEntries();
            }
            if (false) {
                new MapVisitorPerformanceTestOfficial().testAirIterateValues();
                new MapVisitorPerformanceTestOfficial().testCSLMIterateValues();
                new MapVisitorPerformanceTestOfficial().testCHMIterateValues();
                new MapVisitorPerformanceTestOfficial().testTreeMapIterateValues();
                new MapVisitorPerformanceTestOfficial().testHashMapIterateValues();
                // Some future Maps
                // new
                // MapVisitorPerformanceTestOfficial().testNitroMapIterateValues();
                // new
                // MapVisitorPerformanceTestOfficial().testOxyIterateValues();
            }
            if (false) {
//                new MapVisitorPerformanceTestOfficial().testAirVisit();
                new MapVisitorPerformanceTestOfficial().testAirVisitThreaded();
                // new MapVisitorPerformanceTestOfficial().testAirStream();
                // new
                // MapVisitorPerformanceTestOfficial().testAirParallelStream();
                new MapVisitorPerformanceTestOfficial().testCSLMStream();
                // new
                // MapVisitorPerformanceTestOfficial().testCSLMParallelStream();
                // new MapVisitorPerformanceTestOfficial().testCHMStream();
                // new
                // MapVisitorPerformanceTestOfficial().testCHMParallelStream();
                // new MapVisitorPerformanceTestOfficial().testTreeStream();
                // new
                // MapVisitorPerformanceTestOfficial().testTreeParallelStream();
                // new MapVisitorPerformanceTestOfficial().testHashStream();
                // new
                // MapVisitorPerformanceTestOfficial().testHashParallelStream();
            }
            if (false) {
                new MapVisitorPerformanceTestOfficial().testTreeStream();
                new MapVisitorPerformanceTestOfficial().testHashStream();
                new MapVisitorPerformanceTestOfficial().testTreeStream();
                new MapVisitorPerformanceTestOfficial().testHashStream();

                // new MapVisitorPerformanceTestOfficial().testNitroMapVisit();
                // new
                // MapVisitorPerformanceTestOfficial().testNitroMapVisitThreaded();
                // new MapVisitorPerformanceTestOfficial().testOxyVisit();
            }
            afterClass();
        } catch (Throwable t) {
            t.printStackTrace();
        }
    }

}
